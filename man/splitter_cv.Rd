% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validation.R
\name{splitter_cv}
\alias{splitter_cv}
\title{Splits partially supervised data into a list of train/test indices for each fold
used as a test set.}
\usage{
splitter_cv(y, obs_folds, partial)
}
\arguments{
\item{y}{vector containing labels (unsupervised data are represented by `NA`)}

\item{obs_folds}{vector containing division of observations into folds
in a format returned by `caret::createFolds(..., list=FALSE)`.
Note that fold for unsupervised observations is represented by `0`s.}

\item{partial}{boolean value.
If `partial = TRUE`, include the `0` fold containing unlabeled observations
in each training set in the resulting train/test splits of the labeled data.
If `partial = FALSE`, simply exclude the unsupervised observations
and - correspondingly - the `0` fold.}
}
\value{
list of length K, where K is the number of folds.
Each element of the list is a list with two named elements `train` and `test`
that include vectors with indices of observations treated as training data
(all data but kth fold) and test data (data from kth fold).
}
\description{
It can either include *all unsupervised* data in each *training set*,
or exclude it from each training set.
This behavior enables fair comparison of semi-supervised methods and
purely supervised methods on the same train/test splits of *labeled data*.
}
\details{
Note that `splitter` invoked on the same `y` and `folds` with different
`partial` settings will invoke different indices for observations from
different folds since excluding labeled data rearranges the range of the
possible indices.
In the examples section we show that these two sets of indicies result
in the same splitting of the observations into respective folds.
}
\examples{
\dontrun{
grouping <- c(0, 2, 2, 1, 1, 0, 0, 1, 1, 3, 1, 2, 2, 2, 3, 3, 3, 3, 0, 0)
ys <- c(NA, "y", "n", "y", "n", NA, NA, "y", "n", "y",
        "n", "y", "y", "y", "y", "n", "n", "n", NA, NA)
splitter_cv(ys, grouping, TRUE)
splitter_cv(ys, grouping, FALSE)

df <- data.frame(grouping=grouping, id=1:20)
splits_partial <- splitter_cv(y = ys, obs_folds = df$grouping, partial=TRUE)
df[splits_partial[[2]]$test, ]
splits_not_partial <- splitter_cv(y = ys, obs_folds = df$grouping, partial = FALSE)
df[!is.na(ys), ][splits_not_partial[[2]]$test, ]
}
}
